import itertools
'''
A permutation, also called an "arrangement number" or "order", is a rearrangement of the elements of an ordered list S 
into a one-to-one correspondence with S itself. 

Treating a string as an ordered list, we may have a permutation of the string. 

For example, when the string s is "abc", a permutation of the string is "bca". 

Thus, a string of length n has n! permutations. 

In this problem, given a string s, you will implement a function str_perm(s) that returns a list of all permutations of s. 

However, the list contains """ no identical permutations""". 

This list should contain the permutations in lexicographical order (a.k.a. alphabetical order) 

The characters used in a string are only lower-case alphabets. 

For example, 
    - when s is "abc", str_perm(s) returns: 
    ["abc", "acb", "bac", "bca", "cab", "cba"]
    - when s is "abb", str_perm(s) returns:
    ["abb", "bab", "bba"]
 

'''


'''
1. no identical permutations ===> set() 
    - you want to use set if there is a word "no repeating" , "no identical" in the problem
2. the result list contains the input string itself 
3. sorting (in lexicographical order / alphabetical order)
'''



def str_perm(s) -> list:

    len_s = len(s) 
    # index_list = []
    result_set = set()
    
    # 결과는 [('a', 'b','c'), ...] 이런식으로 나옴 
    temp =   itertools.permutations(s, len_s)
    for element in temp:
        result_set.add(''.join(element))

    # check if there is same result in result_list 
    # repeating = use set data structure 
    result = list(result_set)
    
    # sorting 
    result.sort()

    return result


def insert_element_at_all_positions(original_list, element_to_insert):
    result = []
    for i in range(len(original_list) + 1):
        new_list = original_list[:i] + [element_to_insert] + original_list[i:]
        result.append(''.join(new_list))
        # print('result: ')
        # print(result)
    return result


'''backtracking'''
# recursion tree for permutations of string "ABC" 
# Function to print permutations of string 
# This function takes 3 parameters :
# 1. string elements in a list 
# 2. starting index of the string 
# 3. ending index of the string 

# s = 'abc' 
'''
              abc              swap: 0 <-> 0, 1, 2
         /     |      \  
     abc      bac      cab     fix: at index 0, swap: 1 <-> 1, 2  
    /  \     /  \      / \
   abc acb  bac bca   cab cba  fix: at index 1, swap: 2 <-> 2 

   if l == r 이면 stop 

'''

def permute(a, l, r, permList):
    # leaves 에 해당
    if l == r:
        permList.append(''.join(a)) 
    else:
        for i in range(l, r):
            # swap the current element with a[l]
            a[l], a[i] = a[i], a[l]
            # based on this swapped state, do the same thing with a[l+1]
            permute(a, l+1, r, permList)
            a[l] , a[i] = a[i], a[l]

def str_perm(str):
    outList = []

    # get all permutations of string 'ABC'
    permute(list(str), 0, len(str), outList) 

    # leave only distinct permutations 
    distinct = set(outList)

    # Turn the set into a list and sort it in an alphabetical order 
    answer = list(distinct) 
    answer.sort() 

    return answer 



# python permutations offical docs implementation 
def permutations(iterable, r=None):
    # permutations('ABCD', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC
    # permutations(range(3)) --> 012 021 102 120 201 210
    pool = tuple(iterable) # tuple is immutable , slicing is possible 
    n = len(pool)
    r = n if r is None else r
    if r > n:
        return # the function return immediately without generating any permutations 
    
    # INIT 
    # indices끼리 자리를 swap해서 나중에는 그에 해당하는 pool안의 알파벳만 가져온다. 
    indices = list(range(n)) # [0, 1, ..., n-1] represent the positions of elements in the `pool`
    cycles = list(range(n, n-r, -1)) # [n, n-1, ...., n-r+1] will be used to generate the permutations 
    
    # yield keyword is similar to the return keyword but there is a difference 
    # as soon as a yield is encounted, the execution of the fn halts and returns a generator iterator object instead of simply returning a value 
    # https://www.simplilearn.com/tutorials/python-tutorial/yield-in-python#:~:text=The%20Yield%20keyword%20in%20Python%20is%20similar%20to%20a%20return,of%20simply%20returning%20a%20value.
    yield tuple(pool[i] for i in indices[:r]) # first permutation is yielded as a tuple. It is generated by selecting the first 'r' elements from the 'pool' using the indices in 'indicies' 
    
    # n은 permutations에 넣을 수 있는 possible element 
    # 위의 예시에서는 'A', 'B', 'C', 'D' 
    while n:
        # for loop 돌면서 
        # 첫번째는 그 다음부터 끝까지랑 swap 
        # 두번째는 그 다음부터 끝까지랑 swap하면서 indices를 update함. 
        
        for i in reversed(range(r)): # iterates over indices in reverse order from r-1 to 0 
            cycles[i] -= 1
            if cycles[i] == 0: # the element at position i has reached its maximum possible position in the permutation, and the algorithm needs to update the indices and cycles 
                indices[i:] = indices[i+1:] + indices[i:i+1] # indices list is updated by moving the element at position i to the end of the list 
                cycles[i] = n - i # n-i is the number of elements remaining after position i 
            else: # there are more permutations to generate 
                j = cycles[i]
                ''''여기가 제일 중요한 듯 함. swap으로 구현'''
                indices[i], indices[-j] = indices[-j], indices[i] # swap 
                yield tuple(pool[i] for i in indices[:r]) # a new permutation is generated and yielded using the updated 'indices' 
                break
        else:
            return # if the loop completes without encountering a 'break', it means that all permutations have been generated, and the function returns 



if __name__ == '__main__':
    s = 'abc'
    # for _ in str_perm(s):
    #     print(_)
    print(str_perm(s))